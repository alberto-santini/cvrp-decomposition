#ifndef POPULATION_H
#define POPULATION_H

#include "Individual.h"
#include "LocalSearch.h"
#include "Split.h"

namespace genvrp {

    typedef std::vector<Individual*> SubPopulation;

    class Population {
    private:
        Params& params;                          // Problem parameters
        Split& split;                            // Split algorithm
        LocalSearch& localSearch;                // Local search structure
        SubPopulation feasibleSubpopulation;     // Feasible subpopulation, kept ordered by increasing penalized cost
        SubPopulation infeasibleSubpopulation;   // Infeasible subpopulation, kept ordered by increasing penalized cost
        std::list<bool> listFeasibilityLoad;     // Load feasibility of the last 100 individuals generated by LS
        std::list<bool> listFeasibilityDuration; // Duration feasibility of the last 100 individuals generated by LS
        Individual bestSolutionRestart;          // Best solution found during the current restart of the algorthm
        Individual bestSolutionOverall;          // Best solution found during the complete execution of the algorithm

        // Evaluates the biased fitness of all individuals in the population
        void updateBiasedFitnesses(SubPopulation& pop);

        // Removes the worst individual in terms of biased fitness
        void removeWorstBiasedFitness(SubPopulation& subpop);

    public:
        // Creates an initial population of individuals
        void generatePopulation();

        // Add an individual in the population (survivor selection is automatically triggered whenever the population reaches its maximum size)
        // Returns TRUE if a new best solution of the run has been found
        bool addIndividual(const Individual* indiv, bool updateFeasible);
        // Version which first applies local search to the individual:
        void addIndividualLS(const Individual* indiv, bool updateFeasible);

        // Cleans all solutions and generates a new initial population (only used when running HGS until a time limit, in which case the algorithm restarts
        // until the time limit is reached)
        void restart();

        // Adaptation of the penalty parameters
        void managePenalties();

        // Select an individal by binary tournament
        Individual* getBinaryTournament();

        // Accesses the best feasible individual from the current restart
        Individual* getBestFeasible() const;

        // Accesses the best infeasible individual from the current restart
        Individual* getBestInfeasible();

        // Accesses the best found solution at all time (including all restarts, if applicable)
        Individual* getBestFound();

        // Get a copy of an elite individual
        Individual getEliteIndividual(double pct) const;

        // Prints population state
        void printState(int nbIter, int nbIterNoImprovement, const std::string& prefix);

        // Returns the average diversity value among the 50% best individuals in the subpopulation
        double getDiversity(const SubPopulation& pop);

        // Returns the average solution value among the 50% best individuals in the subpopulation
        double getAverageCost(const SubPopulation& pop);

        // Overwrites a solution written in a file if the current solution is better
        void exportBKS(std::string fileName);

        // Constructor
        Population(Params& params, Split& split, LocalSearch& localSearch);

        // Destructor
        ~Population();
    };

} // namespace genvrp

#endif
